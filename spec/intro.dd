Ddoc

$(SPEC_S はじめに,

$(P D言語は汎用システムプログラミング言語で、ネイティブコードにコンパイルされます。
Cライクな構文を持ち、静的に型付けされます。ガベージコレクションによる自動メモリ管理をサポートします。
手動でのメモリ管理にも対応しています。
D言語のプログラムは、ネイティブライブラリや実行可能ファイルを作成するために、
個別にコンパイルし外部ライブラリとリンク可能なモジュールとして構成されます。)

$(P このドキュメントは、プログラミング言語Dのリファレンスマニュアルです。 詳細な情報やその他のドキュメントについては
$(COMMA) $(LINK2 https://dlang.org/, D言語のWebサイト)を参照してください。)

$(H2 コンパイルのフェーズ)

$(P コンパイルは複数のフェーズに分かれます。各フェーズは、後続のフェーズから独立しています。
たとえば、構文解析スキャナーは意味解析の影響を受けません。フェーズの分離により、構文解析を行うエディターなどのツールを比較的簡単に作成できます。)

$(OL
        $(LI $(B ソースの文字セット)$(BR)

        ソースファイルをチェックすることでエンコーディングが決定され、適切な解析スキャナーがロードされます。
        7ビットのASCIIおよびUTFエンコーディングに対応しています。
        )

        $(LI $(B スクリプト行) $(BR)

        最初の行が "$(HASH)!" で始まる場合、その行はスクリプト行として無視されます。
        )

        $(LI $(B 字句解析)$(BR)

        ソースファイルは一連のトークンに分割されます。
        $(DDSUBLINK spec/lex, specialtokens, スペシャルトークン$(LPAREN)Special tokens$(RPAREN))
        は、他のトークンに置き換えられます。
        $(DDSUBLINK spec/lex, special-token-sequence, スペシャルトークンシーケンス$(LPAREN)SpecialTokenSequence$(RPAREN))
        は、処理後に削除されます。
        )

        $(LI $(B 構文解析)$(BR)

        トークンが順序通りに解析されて、構文ツリーが形成されます。
        )

        $(LI $(B 意味解析)$(BR)

        構文ツリーから、変数の宣言、シンボルテーブルのロード、型の割り当て、およびプログラムの意味を決定します。
        )

        $(LI $(B 最適化)$(BR)

        最適化は、意味的に同等でパフォーマンスが高くなるプログラムに書き換えるためのオプションパスです。
        )

        $(LI $(B コード生成)$(BR)

        プログラムを実装するために、ターゲットアーキテクチャから命令が選択されます。
        典型的な結果として、リンカへの入力に適したオブジェクトファイルになります。
        )
)


$(H2 $(LNAME2 memory-model, メモリモデル))

    $(P $(I バイト) はストレージの基本単位です。 各バイトは8ビットで、一意のアドレスに格納されます。
    A $(I メモリロケーション) は、スカラー型を保持するために必要な1バイト以上のシーケンスです。
    複数のスレッドは、干渉することなく別々のメモリロケーションにアクセスできます。
    )

    $(P メモリロケーションは3つのグループに分けられます:)

    $(OL
    $(LI $(I スレッドローカルなメモリロケーション) は、一度に1つのスレッドからのみアクセスできます。)
    $(LI $(I immutable なメモリロケーション) は、存続期間中は書き込むことができません。 immutable な
    メモリロケーション 同期せずに複数のスレッドから読み取ることができます。)
    $(LI $(I Shared メモリロケーション) は、複数のスレッドからアクセスできます。)
    )

    $(未定義動作 複数のスレッドをスレッドローカルなメモリロケーションにアクセスさせることは、未定義の動作になります。)

    $(未定義動作 存続期間中の immutable なメモリロケーションへの書き込みは、未定義の動作になります。)

    $(未定義動作 1つ以上のスレッドが Shared メモリロケーションの読み取りまたは書き込みを行っている間に、
    他のスレッドが同じ場所に書き込むことは、すべての読み取りと書き込みが同期されていない限り、未定義の動作になります。)

    $(P スレッドローカルおよび immutable なメモリロケーションでの単一スレッドの実行は、$(I 順次一貫性)があります。
    これは、メモリ操作の集合的な結果が、プログラムに表示されるのと同じ順序で実行された場合と同じであることを意味します。
    )

    $(P メモリロケーションへの参照が1つしかない場合は、メモリロケーションをスレッドローカルから
    immutable や Shared に移すことができます。)

    $(P メモリロケーションへの参照が1つしかない場合は、メモリロケーションを
    Shared から immutable やスレッドローカルに移すことができます。)

    $(P メモリ操作中に他のスレッドがメモリロケーションにアクセスするのを防ぐために同期が使用されている場合、
    メモリロケーションを Shared　からスレッドローカルに、一時的に移すことができます。)


$(H2 $(LNAME2 object-model, オブジェクトモデル))

    $(P An $(I object) is created in the following circumstances:
    )

    $(UL
    $(LI a definition)
    $(LI a $(GLINK2 expression, NewExpression))
    $(LI a temporary is created)
    $(LI changing which field of a union is active)
    )

    $(P An object spans a sequence of memory locations which may or may not
    be contiguous. Its lifetime encompasses construction, destruction, and the period in between.
    Each object has a type which is determined either statically or by runtime
    type information.
    The object's memory locations may include any combination of thread-local, immutable, or
    shared.
    )

    $(P Objects can be composed into a $(I composed object). Objects that make up
    a composed object are $(I subobjects). An object that is not the subobject
    of another object is a $(I complete object). The lifetime of a subobject
    is always within the lifetime of the complete object to which it belongs.
    )

    $(P An object's address is the address of the first byte of the first memory
    location for that object. Object addresses are distinct unless one
    object is nested within the other.
    )

$(H2 $(LNAME2 arithmetic, 四則演算))

    $(H3 Integer Arithmetic)

    $(P Integer arithmetic is performed using
    $(LINK2 https://en.wikipedia.org/wiki/Two%27s_complement, two's complement) math.
    Integer overflow is not checked for.
    )

    $(H3 Floating Point Arithmetic)

    $(P Floating point arithmetic is performed using
    $(LINK2 https://en.wikipedia.org/wiki/IEEE_754, IEEE-754 floating point math).)

$(SPEC_SUBNAV_NEXT lex, Lexical)
)

Macros:
TITLE = はじめに
CHAPTER = 1
